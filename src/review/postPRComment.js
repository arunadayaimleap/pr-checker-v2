const fs = require('fs-extra');
const path = require('path');
const axios = require('axios');

/**
 * Formats the PR comment with all analysis results
 * @param {Object} data - All analysis results
 * @returns {Promise<string>} Formatted markdown comment
 */
async function formatComment(data) {
  const {
    summary,
    schema,
    flowcharts,
    subsystems,
    smells,
    dependencyIssues,
    securityIssues,
    mermaidDiagrams,
    drawioDiagrams,
    targetPath,
    changedFiles
  } = data;
  
  // Build the comment in sections
  let comment = `# üß† Visual PR Checker Analysis\n\n`;
  
  // Add summary section
  comment += formatSummarySection(summary, changedFiles);
  
  // Add impact section
  if (summary && summary.impact) {
    comment += formatImpactSection(summary.impact);
  }
  
  // Add separator
  comment += `\n---\n\n`;
  
  // Add directory tree visualization (from mermaid diagrams)
  const directoryTree = mermaidDiagrams?.find(d => d.type === 'directory-tree');
  if (directoryTree && directoryTree.imageData) {
    comment += formatDirectoryTreeSection(directoryTree);
  }
  
  // Add subsystem analysis
  if (subsystems && subsystems.subsystems && subsystems.subsystems.length > 0) {
    comment += formatSubsystemSection(subsystems, mermaidDiagrams);
  }
  
  // Add schema diagrams
  if (schema && schema.diagramType !== 'none') {
    comment += formatSchemaSection(schema, drawioDiagrams);
  }
  
  // Add flowcharts
  if (flowcharts && flowcharts.length > 0) {
    comment += formatFlowchartSection(flowcharts, drawioDiagrams);
  }
  
  // Add code smells
  if (smells && smells.length > 0) {
    comment += formatCodeSmellsSection(smells);
  }
  
  // Add dependency issues
  if (dependencyIssues && (dependencyIssues.vulnerabilities || dependencyIssues.outdatedPackages)) {
    comment += formatDependencySection(dependencyIssues);
  }
  
  // Add security issues
  if (securityIssues && securityIssues.issues && securityIssues.issues.length > 0) {
    comment += formatSecuritySection(securityIssues);
  }
  
  // Add footer
  comment += `\n---\n\n`;
  comment += `*Generated by [Visual PR Checker](https://github.com/yourusername/pr-checker-v2) with ‚ù§Ô∏è and üß†*\n`;
  
  return comment;
}

/**
 * Formats the summary section
 * @param {Object} summary - Summary data
 * @param {Array<Object>} changedFiles - Changed files
 * @returns {string} Formatted summary section
 */
function formatSummarySection(summary, changedFiles) {
  let section = `## ü§ñ AI Summary\n\n`;
  
  if (summary && summary.summary) {
    section += summary.summary;
  } else {
    section += `- ${changedFiles.length} files changed in this PR\n`;
    changedFiles.slice(0, 5).forEach(file => {
      section += `- \`${file.path}\` ${file.isNew ? '(new file)' : '(modified)'}\n`;
    });
    if (changedFiles.length > 5) {
      section += `- ...and ${changedFiles.length - 5} more files\n`;
    }
  }
  
  return section + '\n';
}

/**
 * Formats the impact section
 * @param {string} impact - Impact description
 * @returns {string} Formatted impact section
 */
function formatImpactSection(impact) {
  return `### üîß Impact\n\n${impact}\n\n`;
}

/**
 * Formats the directory tree section
 * @param {Object} directoryTree - Directory tree diagram
 * @returns {string} Formatted directory tree section
 */
function formatDirectoryTreeSection(directoryTree) {
  let section = `## üìÇ Directory Structure\n\n`;
  
  if (directoryTree.error) {
    section += `*Error rendering directory structure: ${directoryTree.error}*\n\n`;
    
    // If we have mermaid code, at least show that
    if (directoryTree.mermaidCode) {
      section += "```mermaid\n" + directoryTree.mermaidCode + "\n```\n\n";
    }
  } else if (directoryTree.imageData) {
    section += `![Directory Structure](data:image/png;base64,${directoryTree.imageData})\n\n`;
  }
  
  return section;
}

/**
 * Formats the subsystem section
 * @param {Object} subsystems - Subsystems data
 * @param {Array<Object>} mermaidDiagrams - Mermaid diagrams
 * @returns {string} Formatted subsystem section
 */
function formatSubsystemSection(subsystems, mermaidDiagrams) {
  let section = `## üß† Subsystems\n\n`;
  
  // If we have a subsystem diagram, show it
  const subsystemDiagram = mermaidDiagrams?.find(d => d.type === 'subsystem-diagram');
  if (subsystemDiagram && subsystemDiagram.imageData) {
    section += `![Subsystem Analysis](data:image/png;base64,${subsystemDiagram.imageData})\n\n`;
  }
  
  // List all subsystems
  if (subsystems.subsystems && subsystems.subsystems.length > 0) {
    section += `### Detected Subsystems\n\n`;
    subsystems.subsystems.forEach(system => {
      section += `- **${system.name}**: ${system.description}\n`;
    });
    section += '\n';
  }
  
  // Show file classifications
  if (subsystems.fileClassifications && subsystems.fileClassifications.length > 0) {
    section += `### File Classifications\n\n`;
    subsystems.fileClassifications.slice(0, 10).forEach(file => {
      section += `- \`${file.filePath}\` ‚Üí ${file.subsystem}${file.confidence ? ` (${file.confidence} confidence)` : ''}\n`;
    });
    
    if (subsystems.fileClassifications.length > 10) {
      section += `- *...and ${subsystems.fileClassifications.length - 10} more files*\n`;
    }
    
    section += '\n';
  }
  
  return section;
}

/**
 * Formats the schema section
 * @param {Object} schema - Schema data
 * @param {Array<Object>} schemaDiagrams - Schema diagrams
 * @returns {string} Formatted schema section
 */
function formatSchemaSection(schema, schemaDiagrams) {
  let section = `## üß© Schema Diagram\n\n`;
  
  if (schema.diagramType === 'none') {
    return ''; // No schema to display
  }
  
  section += `${schema.description}\n\n`;
  
  // Show rendered image if available
  const schemaDiagram = schemaDiagrams?.find(d => d.type === 'schema');
  if (schemaDiagram && schemaDiagram.imageData) {
    section += `![Schema Diagram](data:image/png;base64,${schemaDiagram.imageData})\n\n`;
  } else if (schema.mermaid && schema.mermaid.content) {
    // Fall back to Mermaid.js code block
    section += "```mermaid\n" + schema.mermaid.content + "\n```\n\n";
  }
  
  return section;
}

/**
 * Formats the flowchart section
 * @param {Array<Object>} flowcharts - Flowchart data
 * @param {Array<Object>} schemaDiagrams - Schema diagrams
 * @returns {string} Formatted flowchart section
 */
function formatFlowchartSection(flowcharts, schemaDiagrams) {
  if (!flowcharts || flowcharts.length === 0) return '';
  
  let section = `## üîÑ Flowcharts\n\n`;
  
  // Group flowcharts by file
  const flowchartsByFile = {};
  flowcharts.forEach(flowchart => {
    if (!flowchart.filePath) return;
    
    if (!flowchartsByFile[flowchart.filePath]) {
      flowchartsByFile[flowchart.filePath] = [];
    }
    flowchartsByFile[flowchart.filePath].push(flowchart);
  });
  
  // For each file, show its flowcharts
  Object.entries(flowchartsByFile).forEach(([filePath, fileFlowcharts]) => {
    section += `### üìÑ ${path.basename(filePath)}\n\n`;
    
    fileFlowcharts.forEach(flowchart => {
      section += `#### ${flowchart.name}\n\n`;
      
      if (flowchart.description) {
        section += `${flowchart.description}\n\n`;
      }
      
      // Look for a rendered diagram
      const flowDiagram = schemaDiagrams?.find(d => 
        d.type === 'flowchart' && 
        d.title?.includes(flowchart.name)
      );
      
      if (flowDiagram && flowDiagram.imageData) {
        section += `![${flowchart.name}](data:image/png;base64,${flowDiagram.imageData})\n\n`;
      } else if (flowchart.mermaidCode) {
        // Fall back to Mermaid code
        section += "```mermaid\n" + flowchart.mermaidCode + "\n```\n\n";
      }
    });
  });
  
  return section;
}

/**
 * Formats the code smells section
 * @param {Array<Object>} smells - Code smells data
 * @returns {string} Formatted code smells section
 */
function formatCodeSmellsSection(smells) {
  if (!smells || smells.length === 0) return '';
  
  let section = `## üö® Code Smells\n\n`;
  
  // Group smells by file
  const smellsByFile = {};
  smells.forEach(smell => {
    if (!smell.filePath) return;
    
    if (!smellsByFile[smell.filePath]) {
      smellsByFile[smell.filePath] = [];
    }
    smellsByFile[smell.filePath].push(smell);
  });
  
  // For each file, show its smells
  Object.entries(smellsByFile).forEach(([filePath, fileSmells]) => {
    section += `### üìÑ ${path.basename(filePath)}\n\n`;
    
    fileSmells.forEach(smell => {
      const severityEmoji = 
        smell.severity === 'high' ? 'üî¥' : 
        smell.severity === 'medium' ? 'üü†' : 
        smell.severity === 'low' ? 'üü°' : '‚ö™';
      
      section += `- ${severityEmoji} **${smell.name}**: ${smell.description}\n`;
      
      if (smell.lineNumbers && smell.lineNumbers.length > 0) {
        section += `  - *Lines: ${smell.lineNumbers.join(', ')}*\n`;
      }
      
      if (smell.suggestions && smell.suggestions.length > 0) {
        section += `  - *Suggestion: ${smell.suggestions[0]}*\n`;
      }
    });
    
    section += '\n';
  });
  
  return section;
}

/**
 * Formats the dependency section
 * @param {Object} dependencyIssues - Dependency issues data
 * @returns {string} Formatted dependency section
 */
function formatDependencySection(dependencyIssues) {
  let section = `## üß∞ Dependencies\n\n`;
  
  if (!dependencyIssues.detected) {
    section += `*${dependencyIssues.summary || 'No dependency files detected in this project.'}*\n\n`;
    return section;
  }
  
  section += `*${dependencyIssues.summary}*\n\n`;
  
  // Show vulnerabilities
  if (dependencyIssues.vulnerabilities && dependencyIssues.vulnerabilities.length > 0) {
    section += `### üõ°Ô∏è Security Vulnerabilities\n\n`;
    
    dependencyIssues.vulnerabilities.forEach(vuln => {
      const severityEmoji = 
        vuln.severity === 'high' ? 'üî¥' : 
        vuln.severity === 'medium' ? 'üü†' : 
        vuln.severity === 'low' ? 'üü°' : '‚ö™';
      
      section += `- ${severityEmoji} **${vuln.package}@${vuln.currentVersion}**: `;
      
      if (vuln.cve) {
        section += `${vuln.cve}\n`;
      } else {
        section += `Potential vulnerability\n`;
      }
      
      if (vuln.recommendation) {
        section += `  - *Recommendation: ${vuln.recommendation}*\n`;
      }
    });
    
    section += '\n';
  }
  
  // Show outdated packages
  if (dependencyIssues.outdatedPackages && dependencyIssues.outdatedPackages.length > 0) {
    section += `### üì¶ Outdated Packages\n\n`;
    
    dependencyIssues.outdatedPackages.forEach(pkg => {
      section += `- **${pkg.package}**: ${pkg.currentVersion} ‚Üí ${pkg.latestVersion}\n`;
    });
    
    section += '\n';
  }
  
  return section;
}

/**
 * Formats the security section
 * @param {Object} securityIssues - Security issues data
 * @returns {string} Formatted security section
 */
function formatSecuritySection(securityIssues) {
  if (!securityIssues.issues || securityIssues.issues.length === 0) return '';
  
  let section = `## üîí Security Analysis\n\n`;
  
  if (securityIssues.summary) {
    section += `*${securityIssues.summary}*\n\n`;
  }
  
  // Group security issues by file
  const issuesByFile = {};
  securityIssues.issues.forEach(issue => {
    if (!issue.filePath) return;
    
    if (!issuesByFile[issue.filePath]) {
      issuesByFile[issue.filePath] = [];
    }
    issuesByFile[issue.filePath].push(issue);
  });
  
  // For each file, show its security issues
  Object.entries(issuesByFile).forEach(([filePath, fileIssues]) => {
    section += `### üìÑ ${path.basename(filePath)}\n\n`;
    
    fileIssues.forEach(issue => {
      const severityEmoji = 
        issue.severity === 'high' ? 'üî¥' : 
        issue.severity === 'medium' ? 'üü†' : 
        issue.severity === 'low' ? 'üü°' : '‚ö™';
      
      section += `- ${severityEmoji} **${issue.name}**: ${issue.description}\n`;
      
      if (issue.lineNumbers && issue.lineNumbers.length > 0) {
        section += `  - *Lines: ${issue.lineNumbers.join(', ')}*\n`;
      }
      
      if (issue.code) {
        section += `  - \`${issue.code.replace(/`/g, '\'')}\`\n`;
      }
      
      if (issue.recommendation) {
        section += `  - *Recommendation: ${issue.recommendation}*\n`;
      }
    });
    
    section += '\n';
  });
  
  return section;
}

/**
 * Posts a comment to the PR
 * @param {string} comment - Comment markdown
 * @returns {Promise<void>}
 */
async function postComment(comment) {
  try {
    const token = process.env.GITHUB_TOKEN;
    if (!token) {
      throw new Error('GitHub token not found.');
    }
    
    let eventData;
    const eventPath = process.env.GITHUB_EVENT_PATH;
    
    if (eventPath) {
      // Running in GitHub Actions
      eventData = JSON.parse(await fs.readFile(eventPath, 'utf8'));
    } else {
      // Running locally, use mock data
      console.log('üìå Using mock PR data for local testing');
      const { createMockPREvent } = require('../utils/mockPRData');
      eventData = createMockPREvent();
    }
    
    // Extract the repository and PR information
    const repo = eventData.repository.full_name;
    const prNumber = eventData.pull_request.number;
    
    // Create a comment on the PR if we're not in local testing mode
    if (process.env.GITHUB_EVENT_PATH) {
      const url = `https://api.github.com/repos/${repo}/issues/${prNumber}/comments`;
      
      await axios.post(
        url,
        { body: comment },
        {
          headers: {
            'Authorization': `token ${token}`,
            'Content-Type': 'application/json',
            'Accept': 'application/vnd.github.v3+json'
          }
        }
      );
      
      console.log(`‚úÖ Successfully posted comment to PR #${prNumber}`);
    } else {
      console.log(`‚úÖ Would post comment to PR #${prNumber} in repo ${repo}`);
      console.log('üí° Comment is saved to pr-review-output.md');
    }
  } catch (error) {
    console.error('Error posting comment to PR:', error.message);
    throw error;
  }
}

module.exports = {
  formatComment,
  postComment
};
